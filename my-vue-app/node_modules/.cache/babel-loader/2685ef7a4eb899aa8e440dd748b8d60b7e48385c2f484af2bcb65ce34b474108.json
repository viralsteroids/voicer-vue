{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nexport default {\n  data() {\n    return {\n      formant1: 'N/A',\n      formant2: 'N/A',\n      tone: 'N/A',\n      harmonicRatio: 'N/A',\n      vowelSound: 'N/A',\n      numHarmonics: 0,\n      note: 'N/A'\n    };\n  },\n  mounted() {\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(stream => {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioContext.createAnalyser();\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n      analyser.fftSize = 2048;\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      const processAudio = () => {\n        analyser.getByteFrequencyData(dataArray);\n        const formant1Frequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 200, 400);\n        const formant2Frequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 1800, 2400);\n        const toneFrequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 60, 300);\n        this.formant1 = formant1Frequency;\n        this.formant2 = formant2Frequency;\n        this.tone = toneFrequency;\n        this.harmonicRatio = this.calculateHarmonicRatio(dataArray, toneFrequency);\n        this.numHarmonics = this.countHarmonics(dataArray, toneFrequency);\n        this.note = this.getNoteFromFrequency(toneFrequency);\n        this.vowelSound = this.identifyVowelSound(formant1Frequency, formant2Frequency);\n        requestAnimationFrame(processAudio);\n      };\n      processAudio();\n    }).catch(err => console.error(err));\n  },\n  methods: {\n    findPeakFrequency(dataArray, sampleRate, minFreq, maxFreq) {\n      const nyquist = sampleRate / 2;\n      const startBin = Math.floor(minFreq / nyquist * dataArray.length);\n      const endBin = Math.floor(maxFreq / nyquist * dataArray.length);\n      let maxMagnitude = -Infinity;\n      let peakBin = startBin;\n      for (let i = startBin; i <= endBin; i++) {\n        if (dataArray[i] > maxMagnitude) {\n          maxMagnitude = dataArray[i];\n          peakBin = i;\n        }\n      }\n      return Math.round(peakBin * nyquist / dataArray.length);\n    },\n    calculateHarmonicRatio(dataArray, fundamentalFreq) {\n      const harmonicSum = dataArray.reduce((acc, val, idx) => {\n        return idx % fundamentalFreq === 0 ? acc + val : acc;\n      }, 0);\n      const noiseSum = dataArray.reduce((acc, val) => acc + val, 0) - harmonicSum;\n      return (20 * Math.log10(harmonicSum / (noiseSum || 1))).toFixed(2);\n    },\n    countHarmonics(dataArray, fundamentalFreq) {\n      const threshold = 0.1 * Math.max(...dataArray);\n      let count = 0;\n      for (let i = fundamentalFreq; i < dataArray.length; i += fundamentalFreq) {\n        if (dataArray[i] >= threshold) {\n          count++;\n        }\n      }\n      return count;\n    },\n    identifyVowelSound(f1, f2) {\n      if (f1 >= 200 && f1 <= 400 && f2 >= 1800 && f2 <= 2400) {\n        return 'И';\n      } else if (f1 >= 350 && f1 <= 500 && f2 >= 700 && f2 <= 1200) {\n        return 'Э';\n      } else if (f1 >= 600 && f1 <= 800 && f2 >= 1000 && f2 <= 1200) {\n        return 'А';\n      } else if (f1 >= 300 && f1 <= 450 && f2 >= 700 && f2 <= 1000) {\n        return 'О';\n      } else if (f1 >= 250 && f1 <= 400 && f2 >= 600 && f2 <= 800) {\n        return 'У';\n      }\n      return 'N/A';\n    },\n    getNoteFromFrequency(frequency) {\n      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n      const A4 = 440;\n      const semitoneOffset = 12 * Math.log2(frequency / A4);\n      const noteIndex = Math.round(semitoneOffset) % 12;\n      return noteNames[(noteIndex + 12) % 12];\n    }\n  }\n};","map":{"version":3,"names":["data","formant1","formant2","tone","harmonicRatio","vowelSound","numHarmonics","note","mounted","navigator","mediaDevices","getUserMedia","audio","then","stream","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","source","createMediaStreamSource","connect","fftSize","bufferLength","frequencyBinCount","dataArray","Uint8Array","processAudio","getByteFrequencyData","formant1Frequency","findPeakFrequency","sampleRate","formant2Frequency","toneFrequency","calculateHarmonicRatio","countHarmonics","getNoteFromFrequency","identifyVowelSound","requestAnimationFrame","catch","err","console","error","methods","minFreq","maxFreq","nyquist","startBin","Math","floor","length","endBin","maxMagnitude","Infinity","peakBin","i","round","fundamentalFreq","harmonicSum","reduce","acc","val","idx","noiseSum","log10","toFixed","threshold","max","count","f1","f2","frequency","noteNames","A4","semitoneOffset","log2","noteIndex"],"sources":["/workspace/voicer-vue/my-vue-app/src/components/AudioAnalyzer.vue"],"sourcesContent":["<template>\n  <div>\n    <h1>Web Sound Analysis</h1>\n    <p>Formant 1: {{ formant1 }} Hz</p>\n    <p>Formant 2: {{ formant2 }} Hz</p>\n    <p>Tone: {{ tone }} Hz - Note: {{ note }}</p>\n    <p>Harmonic Ratio: {{ harmonicRatio }} dB</p>\n    <p>Vowel Sound: {{ vowelSound }}</p>\n    <p>Number of Harmonics: {{ numHarmonics }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      formant1: 'N/A',\n      formant2: 'N/A',\n      tone: 'N/A',\n      harmonicRatio: 'N/A',\n      vowelSound: 'N/A',\n      numHarmonics: 0,\n      note: 'N/A',\n    };\n  },\n  mounted() {\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then(stream => {\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n\n        analyser.fftSize = 2048;\n        const bufferLength = analyser.frequencyBinCount;\n        const dataArray = new Uint8Array(bufferLength);\n\n        const processAudio = () => {\n          analyser.getByteFrequencyData(dataArray);\n\n          const formant1Frequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 200, 400);\n          const formant2Frequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 1800, 2400);\n          const toneFrequency = this.findPeakFrequency(dataArray, audioContext.sampleRate, 60, 300);\n\n          this.formant1 = formant1Frequency;\n          this.formant2 = formant2Frequency;\n          this.tone = toneFrequency;\n          this.harmonicRatio = this.calculateHarmonicRatio(dataArray, toneFrequency);\n          this.numHarmonics = this.countHarmonics(dataArray, toneFrequency);\n          this.note = this.getNoteFromFrequency(toneFrequency);\n          this.vowelSound = this.identifyVowelSound(formant1Frequency, formant2Frequency);\n\n          requestAnimationFrame(processAudio);\n        };\n\n        processAudio();\n      })\n      .catch(err => console.error(err));\n  },\n  methods: {\n    findPeakFrequency(dataArray, sampleRate, minFreq, maxFreq) {\n      const nyquist = sampleRate / 2;\n      const startBin = Math.floor(minFreq / nyquist * dataArray.length);\n      const endBin = Math.floor(maxFreq / nyquist * dataArray.length);\n\n      let maxMagnitude = -Infinity;\n      let peakBin = startBin;\n\n      for (let i = startBin; i <= endBin; i++) {\n        if (dataArray[i] > maxMagnitude) {\n          maxMagnitude = dataArray[i];\n          peakBin = i;\n        }\n      }\n\n      return Math.round((peakBin * nyquist) / dataArray.length);\n    },\n    calculateHarmonicRatio(dataArray, fundamentalFreq) {\n      const harmonicSum = dataArray.reduce((acc, val, idx) => {\n        return idx % fundamentalFreq === 0 ? acc + val : acc;\n      }, 0);\n      const noiseSum = dataArray.reduce((acc, val) => acc + val, 0) - harmonicSum;\n\n      return (20 * Math.log10(harmonicSum / (noiseSum || 1))).toFixed(2);\n    },\n    countHarmonics(dataArray, fundamentalFreq) {\n      const threshold = 0.1 * Math.max(...dataArray);\n      let count = 0;\n\n      for (let i = fundamentalFreq; i < dataArray.length; i += fundamentalFreq) {\n        if (dataArray[i] >= threshold) {\n          count++;\n        }\n      }\n\n      return count;\n    },\n    identifyVowelSound(f1, f2) {\n      if (f1 >= 200 && f1 <= 400 && f2 >= 1800 && f2 <= 2400) {\n        return 'И';\n      } else if (f1 >= 350 && f1 <= 500 && f2 >= 700 && f2 <= 1200) {\n        return 'Э';\n      } else if (f1 >= 600 && f1 <= 800 && f2 >= 1000 && f2 <= 1200) {\n        return 'А';\n      } else if (f1 >= 300 && f1 <= 450 && f2 >= 700 && f2 <= 1000) {\n        return 'О';\n      } else if (f1 >= 250 && f1 <= 400 && f2 >= 600 && f2 <= 800) {\n        return 'У';\n      }\n      return 'N/A';\n    },\n    getNoteFromFrequency(frequency) {\n      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n      const A4 = 440;\n      const semitoneOffset = 12 * Math.log2(frequency / A4);\n      const noteIndex = Math.round(semitoneOffset) % 12;\n      return noteNames[(noteIndex + 12) % 12];\n    }\n  }\n};\n</script>\n\n<style>\nh1 {\n  font-size: 24px;\n  margin-bottom: 16px;\n}\np {\n  font-size: 18px;\n  margin: 8px 0;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}